function nav(data, parent) {
  // helper function to compute the distance between two points in pixel
  function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1-x2, 2) + Math.pow(y1-y2, 2))
  }

  var nav = {}
  // generate the navigation graph; nodes are pairs of traits, and an edge
  // between two nodes exist if they share a common trait
  nav.generateGraph = function() {
    // helper function to see whether two arrays have an element in common
    function intersects(array1, array2){
      for (var i=0; i<array1.length; i++)
        for (var j=0; j<array2.length; j++)
          if (array1[i] == array2[j]) return true;
      return false;
    } 
    var nodes = [], edges = [],
        ntraits = data.traits.length,
        numNodes = ntraits * (ntraits-1) / 2
    var k = 0
    for (var i = 0; i < ntraits; i++) {
      for (var j = i+1; j < ntraits; j++) {
        // push the node identifying pairs of coordinates
        var node = {
          name: data.traits[i]+':'+data.traits[j],
          traits: [data.traits[i], data.traits[j]],
          cos: Math.cos(2*Math.PI*k/numNodes),
          sin: Math.sin(2*Math.PI*k/numNodes),
          edges: [],
          active: false,
        }
        nodes.push(node)
        // push each edge where 2 nodes share at least one trait
        for (var l = 0; l < k; l++) {
          var otherNode = nodes[l]
          if (intersects(node.traits, otherNode.traits)) {
            var edge = { source: node, target: otherNode, active: false }
            edges.push(edge);
            node.edges.push(edge)
            otherNode.edges.push(edge)
          }
        }
        k += 1
      }
    }
    nav.graph = { nodes:nodes, edges:edges }
    nav.graph.reset = function () {
      for (var i=0; i<this.nodes.length; i++) {
        this.nodes[i].active = false;
      }
      for (var i=0; i<this.edges.length; i++) {
        this.edges[i].active = false;
      }
    }
    return nav.graph
  }

  // set up the navigation graph
  nav.setup = function(height, width, padding) {
    // first set up the nodes & edges
    this.graph = nav.generateGraph()
    nav.width = width
    nav.height = height
    nav.padding = padding

    return nav
  }

  nav.plot = function(mainDiv) {
    // set up the canvas
    var chart = d3.select(mainDiv)
        .append("svg")
        .attr("width", this.width + 2*this.padding)
        .attr("height", this.height + 2*this.padding);

    // helper function to scale the "x" and "y"s generated by generateGraph
    // into pixels on the screen
    function scale(a, shift, length) {
      if (!length) length = shift 
      return a*length/2 + shift/2;
    }
    function scaleWidth(d) { return scale(d.cos, nav.width) }
    function scaleHeight(d) { return scale(d.sin, nav.height) }
    for (var i=0; i< this.graph.edges.length; i++) {
      var edge = this.graph.edges[i]
      edge.length = distance(scaleWidth(edge.source), scaleHeight(edge.source),
                             scaleWidth(edge.target), scaleHeight(edge.target))
    }
    function activateEdge(edge) {
      edge.active = true;
      edge.target.active = true;
      edge.source.active = true;
    }

    // activate the first elt & plot the scatter plot
    var initialNode = this.graph.nodes[0]
    for (var i = 0; i< initialNode.edges.length; i++) {
      activateEdge(initialNode.edges[i])
    }
    parent.scatter.position(initialNode.traits[0], initialNode.traits[1], 0.5)

    // position the non-moving elements: nodes edges and labels
    this.edges = chart.selectAll("line.link")
          .data(this.graph.edges)
        .enter().append("line")
          .attr("class", "link")
          .attr("transform", "translate("+this.padding+","+this.padding+")")
          .attr("x1", function(d) { return scaleWidth(d.source); })
          .attr("y1", function(d) { return scaleHeight(d.source); })
          .attr("x2", function(d) { return scaleWidth(d.target); })
          .attr("y2", function(d) { return scaleHeight(d.target); })
          .style("stroke-width", 3)
          .style("stroke", colour.nav)
          .attr("class", function(d) {
            if (d.active) {
              return "link active";
            } return "link"
          });

    this.nodes = chart.selectAll("circle.node")
          .data(this.graph.nodes)
        .enter().append("circle")
          .attr("class", "node")
          .attr("transform", "translate("+this.padding+","+this.padding+")")
          .attr("cx", scaleWidth)
          .attr("cy", scaleHeight)
          .attr("r", 15)
          .style("fill", colour.nav)
          .attr("class", function(d) {
            if (d.active) { 
              return "node active";
            } return "node"
          });

    var labels = chart.selectAll("labeltext")
          .data(this.graph.nodes)
        .enter().append("text")
          .attr("class", "text")
          .attr("transform", "translate("+this.padding+","+(this.padding+3)+")")
          .attr("x", function(d) { return scale(d.cos, nav.width, nav.width+85)})
          .attr("y", function(d) { return scale(d.sin, nav.height, nav.height+55)})
          .text(function(d) { return d.name })
          .attr("text-anchor", "middle")

    // position the selector
    selector = chart.selectAll("selectornode")
          .data([1])
        .enter().append("circle")
          .attr("class", "selector")
          .attr("transform", "translate("+this.padding+","+this.padding+")")
          .attr("cx", scale(1, this.width))
          .attr("cy", scale(0, this.height))
          .attr("r", 13)
          .style("fill", colour.selector)

    selector.selected = initialNode
    selector.selectedEdge = null

    // movement to another (active) node
    this.nodes.on("click", function(node) { 
      if (node.active) {
        selector.selected = node
        // reset active elements 
        nav.graph.reset()
        for (var i=0; i<node.edges.length; i++) {
          activateEdge(node.edges[i])
        }
        // calculate the amount of movement/transition to be made
        var transition = 0.8 
        if (selector.selectedEdge) {
          transition = (distance(selector.attr("cx"), selector.attr("cy"),
                                  scaleWidth(node), scaleHeight(node))
                        / selector.selectedEdge.length)
        }
        // plot!!
        parent.scatter.position(node.traits[0], node.traits[1], transition)
        nav.replot(scaleWidth(node), scaleHeight(node), transition)
        selector.selectedEdge = null
      }
    });

    // movement to the middle of an edge (requires interpolation)
    this.edges.on("mousedown", function(edge) {
      if (edge.active) {
        var x, y
        if (d3.event.offsetX) {
          x = d3.event.offsetX-nav.padding
          y = d3.event.offsetY-nav.padding
        } else {
          //This is a hack!!
          x = d3.event.layerX-nav.padding-20
          y = d3.event.layerY-nav.padding-70
        }
        selector.selectedEdge = edge
        // reset active elements
        nav.graph.reset()
        activateEdge(edge)
        // calculate the amount of movement/transition to be made
        transition = (distance(selector.attr("cx"),selector.attr("cy"), x, y)
                        / edge.length)
        // calculate direction that the scatter plot is rotating towards
        // and other useful data
        var rotatingTo = edge.target
        if (selector.selected == edge.target) {
          rotatingTo = edge.source
        }
        var interpolation = (distance(x, y, scaleWidth(rotatingTo),
                                            scaleHeight(rotatingTo))
                              / edge.length)
        // plot!!
        parent.scatter.interpolate(rotatingTo.traits[0], rotatingTo.traits[1],
                                   interpolation, transition)
        nav.replot(x, y, transition)
      }
    });
    this.selector = selector
    this.chart = chart
    return nav
  }

  // function to replot nodes & edges
  nav.replot = function(selectorX, selectorY, transition) {
    this.chart.selectAll("line.link")
       .style("stroke", colour.nav)
       .attr("class", function(d) {
         if (d.active) {
           return "link active";
         } return "link"
       })
    this.chart.selectAll("circle.node") // recolour nods
       .style("fill", colour.nav)
       .attr("class", function(d) {
         if (d.active) { 
           return "node active";
         } return "node"
       })
    this.selector.transition() // move the selector
            .ease("linear")
            .duration(1000 * transition)
            .attr("cx", selectorX)
            .attr("cy", selectorY)
    return nav;
  }

  return nav;
}
