// helper function to see whether two arrays have an element in common
Array.prototype.intersects = function(search){
  for (var i=0; i<this.length; i++)
    for (var j=0; j<search.length; j++)
      if (this[i] == search[j]) return true;
  return false;
} 

// generate the navigation graph; nodes are pairs of traits, and an edge
// between two nodes exist if they share a common trait
function generateGraph(width, height) {
  var nodes = [],
      edges = [],
      ntraits = data.traits.length,
      numNodes = ntraits * (ntraits-1) / 2

  var k = 0
  for (var i = 0; i < ntraits; i++) {
    for (var j = i+1; j < ntraits; j++) {
      // push the node identifying pairs of coordinates
      var node = {
        id: k,
        name: data.traits[i]+':'+data.traits[j],
        traits: [data.traits[i], data.traits[j]],
        x: Math.cos(2*Math.PI*k/numNodes),
        y: Math.sin(2*Math.PI*k/numNodes),
        edges: [],
        active: false,
      }
      nodes.push(node)
      // push each edge where 2 nodes share at least one trait
      for (var l = 0; l < k; l++) {
        var otherNode = nodes[l]
        if (node.traits.intersects(otherNode.traits)) {
          var edge = { source: node, target: otherNode, active: false }
          edges.push(edge);
          node.edges.push(edge)
          otherNode.edges.push(edge)
        }
      }
      k += 1
    }
  }
  graph = { nodes:nodes, edges:edges }
  graph.reset = function () {
    for (var i=0; i<this.nodes.length; i++) {
      this.nodes[i].active = false;
    }
    for (var i=0; i<this.edges.length; i++) {
      this.edges[i].active = false;
    }
  }
  return graph
}

// set up the navigation graph
function setupNav(height, width, padding, mainDiv) {
  // first set up the nodes & edges
  graph = generateGraph(width, height)

  // set up the canvas
  nav = d3.select(mainDiv).append("svg")
      .attr("width", width + 2*padding)
      .attr("height", height + 2*padding);

  // helper function to scale the "x" and "y"s generated by generateGraph
  // into pixels on the screen
  function scale(a, shift, length) {
    if (!length) length = shift 
    return a*length/2 + shift/2;
  }

  // position the non-moving elements: nodes edges and labels
  var edges = nav.selectAll("line.link")
        .data(graph.edges)
      .enter().append("line")
        .attr("class", "link")
        .attr("transform", "translate("+padding+","+padding+")")
        .attr("x1", function(d) { return scale(d.source.x, width); })
        .attr("y1", function(d) { return scale(d.source.y, height); })
        .attr("x2", function(d) { return scale(d.target.x, width); })
        .attr("y2", function(d) { return scale(d.target.y, height); })
        .style("stroke-width", 2)
        .style("stroke", colour.nav)

  var nodes = nav.selectAll("circle.node")
        .data(graph.nodes)
      .enter().append("circle")
        .attr("class", "node")
        .attr("transform", "translate("+padding+","+padding+")")
        .attr("cx", function(d) { return scale(d.x, width); })
        .attr("cy", function(d) { return scale(d.y, height); })
        .attr("r", 15)
        .style("fill", colour.nav)

  var labels = nav.selectAll("labeltext")
        .data(graph.nodes)
      .enter().append("text")
        .attr("class", "text")
        .attr("transform", "translate("+padding+","+(padding+3)+")")
        .attr("x", function(d) { return scale(d.x, width, width+85)})
        .attr("y", function(d) { return scale(d.y, height, height+55)})
        .text(function(d) { return d.name })
        .attr("text-anchor", "middle")

  // position the selector
  selector = nav.selectAll("selectornode")
        .data([1])
      .enter().append("circle")
        .attr("class", "node")
        .attr("transform", "translate("+padding+","+padding+")")
        .attr("cx", scale(1, width))
        .attr("cy", scale(0, height))
        .attr("r", 13)

  // active nodes & edges

  selector.activeEdges = function() {
    if (selector.selected) {
      edges = selector.selected.edges
      for (var i=0; i<edges.length; i++) {
        edges[i].active = true
      }
      return edges;
    }
    return []
  }

  selector.activeNodes = function () {
    var nodes = []
    var edges = selector.activeEdges()
    selector.selected.active = true

    for (var i=0; i<edges.length; i++) {
      edge = edges[i]
      if (edge.source == selector.selected) {
        node = edge.target;
      } else {
        node = edge.source;
      }
      node.active = true
      nodes.push(node);
    }
    return nodes;
  }

  // call this to update active nodes & edgs
  selector.select = function(node, first) {
    if (!node.active && !first) {
      return
    }

    current = selector.selected

    graph.reset()
    selector.selected = node
    selector.activeEdges()
    selector.activeNodes()

    selector.transition()
            .duration(1000)
            .attr("cx", scale(node.x, width))
            .attr("cy", scale(node.y, height))

    scatter.plot(node.traits[0], node.traits[1])

    nav.selectAll("line.link").style("stroke", colour.nav)
    nav.selectAll("circle.node").style("fill", colour.nav)
    selector.style("fill", colour.selector)
  }
  selector.select(graph.nodes[0], true)

  nodes.on("click", function(d,i) { selector.select(d) })

  // MOVEMENT RELATED
  /*
  selector.move = function () {
    selector.attr("cx", d3.event.x-padding)
            .attr("cy", d3.event.y-padding)
  }

  selector.call(function() {
    drag = d3.behavior.drag()
      .on("dragstart", function() { selector.style("fill", colour.drag) })
      .on("dragend", function() { selector.style("fill", colour.selector) })
      .on("drag", this.move)
    this.call(drag);
  });
  */
}
